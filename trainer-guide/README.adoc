:sectnums:

= Trainer guide

The goal of this workshop is to introduce the new features of Java from version 14 to 22.

More specifically we will focus on _data oriented programming_, that is to say the use of records, sealed interfaces, pattern matching and other type related features.

*We want to ask more of Java type system.*

== Step 1: Introducing records

=== Make `TrumpCard` a `record`

Underline the following features:

* Implicit `index`
* Implicit `equals` & `hashcode`
* Implicit constructor

[WARNING]
--
No compact constructor at this point
--

=== Add `RoyalSuitCard` and `NumberSuitCard` as records inheriting from `SuitCard`

Again asking more from the type system: a suit card with en index lower than 10 should not have a face, and vice versa. This should NOT be a control in a constructor, this should be ensured by the compiler

[WARNING]
--
No compact constructor at this point
--

=== Constrain `TrumpCard`, `RoyalPlayingCard` and `NumberPlayingCard` :
* Constraints :
** `NumberPlayingCard` has no `Face`
** `RoyalPlayingCard` 's index is correlated to its `Face`
** `RoyalPlayingCard` 's `Color` and `Face` cannot be `null` (compact constructor)
** `NumberPlayingCard` 's `Color` and `Index` cannot be `null` and the `Index` must be between 1 and 10 (included)
** `TrumpCard` 's `Index` must be between 0 and 21 (included)

=== Showing the limitation of open heritage

Ask for a `Joker` class inheriting from `PlayingCard`

Display it using `PrettyPrinter` and observe the potential issue.

== Step 2: Introducing sealed interfaces

Start solving the *Joker case*:

* Explain the sealed interface hierarchie represent a close world, or at least explicit their extension points.
* Constrain `PlayingCard` to be either a `SuitCard` or a `TrumpCard` using a sealed interface (`Joker` may be removed at this point)
* Make `SuitCard` a sealed interface as well

== Step 3: Introducing pattern matching

All this part takes place in the `PrettyPrinter` class.

Clean the `PrettyPrinter` (step by step) :

* Use pattern matching in the `instanceof` expression +
Don't forget to point that `"".formated()` is a thing now.
* Mutate the switch to a statement, ie `var result = switch(playingCard) { ... }`
* Introduce switch on types. +
The `toString` method is now a giant switch.
* Introduce guarded case patterns, ie `case NumberPlayingCard card when card.index() == 1 ->`
* Add destructuration to the switch,ie `case TrumpCard(Integer idx) ->`)

[WARNING]
--
No more `default` case is needed in the end because the switch won't compile if all cases aren't covered
--

== Uncomment tests

They shall pass \o/